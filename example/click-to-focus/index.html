<html>
<head>
  <style> body { margin: 0; } </style>

  <script src="/node_modules/three/build/three.js"></script>
  <script src="https://unpkg.com/d3-force-3d"></script>
  <script src="https://unpkg.com/3d-force-graph"></script>
  <script src="../../src/lib/prep-graph-dataset.js"></script>
  <!-- <script src="../../src/3d-force-graph.js"></script> -->
</head>

<body>
  <div id="3d-graph"></div>

  <script>
    // https://stackoverflow.com/questions/16991341/json-parse-file-path
    const request = new XMLHttpRequest();
    request.open("GET", "../datasets/hierarchic-graph.json", false);
    request.send(null)
    const jsonFromFile = JSON.parse(request.responseText).slice(1);
    const graphData = hierarchicToGraph(jsonFromFile);

    const elem = document.getElementById('3d-graph');
    const Graph = ForceGraph3D({linkColor: 'red'})(elem)
      .graphData(graphData);
    //link strength: calc the intended distance instead of a strength?
    // - no, because hard to do (performance issues?)
    // - instead, let strengths act like 'charges' that self-organize using the physics engine

    function setNodeId(node) {
      return node.id; }
    // Graph.d3Force('link')

    function linkStrength(link) {
      return (1 / link.sourceLevel); }
    const graphLinksSubset = graphData.links
      .filter( link => link.sourceLevel === 6 );
    const graphNodesSubset = graphLinksSubset
      .map( link => {
        return [
          graphData.nodes
            .find( node => node.id === link.source ),
          graphData.nodes
            .find( node => node.id === link.target )
        ] }).flat();
    const graphDataSubset = {
      nodes: [...graphNodesSubset],
      links: [...graphLinksSubset]
    }

    // Graph.d3Force('link', d3.forceLink(graphDataSubset)
    //   .distance( link=> {
    //     const power = 2
    //     const calc = Math.pow(link.sourceLevel, power)
    //     return calc
    //   } )
    //   .id( (d,i) => setNodeId(d) )
    //   // .strength( d => linkStrength(d) )
    // );
    // Graph.d3Force('charge')
    // .strength( node => {
    //   // const calc = node.level === '8' ?
    //   //   200 : 10;
    //   const calc = Math.pow(2, node.level*0.75)
    //   return -calc })

    // Graph.d3Force('center', d3.forceCenter()); // 0,0,0; ought set strength
    const maxLevel = 8;
    Graph.d3Force('y', d3.forceY( node => {
      let calc1 = Math.pow(2, (1/ (node.level/5))*4) *10
      const goldenRatio = (1 + Math.sqrt(5))/2;
      const reversedLevel = maxLevel - node.level + 1
      let calc = Math.pow(goldenRatio, reversedLevel) * 50
      calc = calc < 2000 ?
        calc : 2000
      console.log("calc", calc)
      return calc })
      // .strength(node => {
      //   const calc = Math.pow(2, node.level*0.75) * 0.002
      //   console.log("strngth", calc)
      //   return 0.05 })
    )

    Graph.d3Force('link')
    .strength(link => {
      const calc1 = Math.pow(3, link.sourceLevel/2) * 0.002;
      return 0 })
    // console.log(d.x + d.group*10);
    // d.parent.linkStrength () || d.cousin.linkStrength (less often have these, as likely they'd feature [connectively] in a Obj-subj scene: 'implicit' parents )
    // Graph.d3Force('x', d3.forceX(d => {
    //   return d.x /* + d.group*50 */ })
    //     .strength( node => {
    //       const calc = Math.pow(
    //         1/parseInt(node.level), 2)
    //         / 3
    //       // debugger;
    //       return calc
    //     })
    // );
    // Graph.d3Force('z', d3.forceZ(d => { return d.group; })
      //.strength( d => { return d.group/10; }) );
    // function linkStrength(link) {
      // return 1 / Math.min(count(link.source), count(link.target));
    // }
    // override the link strength function
    // Graph.d3Force('link').strength( d => linkStrength(d) );
    // https://github.com/vasturiano/d3-force-3d#forceLink

// function makeGraph (){} // call from async
    Graph
      // .jsonUrl('../datasets/miserables.json')
      // .nodeLabel('id')
      .nodeAutoColorBy('group')
      .linkColor(link => {
        const calc = link.sourceLevel === 5 ?
          'rgba(255,0,0,1)' : 'rgba(255,255,255,1)'
        return calc })
      .linkWidth(link => 2)
      // .nodeColor(node => 'rgba(255,0,0,1)')
      .onNodeHover(node => elem.style.cursor = node ? 'pointer' : null)
      .onNodeClick(node => {
        // Aim at node from outside it
        const cameraDistance = 40;
        // const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

      // make vector between nodes, by feeding new Vector() with result of:
        // take camera position; subtract node postion
        const cameraPosition = Graph.cameraPosition()
        const vecToNodeData = [ cameraPosition.x - node.x, cameraPosition.y - node.y, cameraPosition.z - node.z ];
        let vecToNode = new THREE.Vector3(...vecToNodeData);
        // normalize this vector (0 to 1)
        vecToNode.normalize();
        // scalar multiply to arrive at a distance
        vecToNode.multiplyScalar( cameraDistance );
        // add node to vector
        // vecToNode.add( node.x, node.y, node.z );
        const toPosition = { x: vecToNode.x + node.x,
                             y: vecToNode.y + node.y,
                             z: vecToNode.z + node.z }
        // move camera to this position
        Graph.cameraPosition(
          // {x: vecToNode.x, y: vecToNode.y, z: vecToNode.z},
          toPosition,
          node,
          3000
        );

        // Graph.cameraPosition(
        //   { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }, // new position
        //   node, // lookAt ({ x, y, z })
        //   3000  // ms transition duration
        // );
      });


  </script>
</body>
</html>
